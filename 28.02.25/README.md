
# По видео с Ютуба:    https://youtu.be/VJm_AjiTEEc

## Публикация изменений в файлах в GitHub:

Делая изменения в файлах в нашем локальном репозитории, когда мы готовы, то можем **сказать гиту**, чтобы он опубликовал все эти изменения в удаленную копию.
Но самостоятельно Гит ничего делать не будет!!!  Он опубликует, только когда вы явно ему скажете об этом.  
Поэтому не стоит переживать о том, что кто-то тут же увидит, какого кринжа вы навалили в коде.


Когда мы загрузим наш новый код в удаленный репозиторий, то другие смогут скачать его на свои ПК. (а точнее не его самого, а только **копию**)
Они возьмут ваш репозиторий и на своих ПК на его основе создадут локальный репозиторий. Но это будет уже другая копия! У каждого пользователя своя копия репозитория.





## Скачивание копии удаленного репозитория на свой ПК:
Сначала в консоли нужно перейти в папку, куда хотим скачать копию удаленного репозитория. (с помощью команды cd в терминале)

Далее запускаем команду **git clone [url удаленного репозитория с GitHub]**
![image](https://github.com/user-attachments/assets/dbb8ee95-91d0-46ee-bf27-4ba22af95fd8)

После этого у нас на компе появится новая папка со всеми файлами, что лежат в удаленном репозитории.
И эта папка сразу является вашим локальным репозиторием.
И этот локальный репозиторий уже автоматически связан с удаленным.
Но опять же, когда мы внесем какие-то изменения в локальном репозитории, они никак не будут отражены в удаленном!
Они появятся в удаленном, только когда мы явно скажем гиту о том, что нужно загрузить их в облако.


## КОММИТЫ. Внесение изменений в файл в вашем локальном репозитории.


Внутри репозитория можно выполнить команду **git status**. Она выведет нам в консоль информацию обо всех незакоммиченных файлах в Гит-репозитории (подсветит их красным). Т.е. о тех, чью версию мы изменили, но еще не сохранили эти изменения внутри Гита.

![image](https://github.com/user-attachments/assets/b923b41a-55dc-4a53-9d64-f08f0699f2dc)

Сохранение конкретной версии файла внутри Гита называется **коммитом**. Т.е. чтобы в будущем была возможность всегда быстро прыгнуть именно на эту версию файла, то это его состояние нужно закоммитеть в гит.

Сначала гиту нужно сказать, какие именно изменения в файле мы хотим сохранить в виде отдельной версии. (= коммита внутри гита)

![image](https://github.com/user-attachments/assets/fac78b6d-630c-40e7-965c-077e190151ad)

Используют команду **git add**. После этой команды нужно указать имена файлов или папок, которые хотим подготовитьк сохранению. 
Чтобы подготовить **сразу все** файлы из текущей директории, можно написать точку ".", которая указывает на директорию, в которой мы прямо сейчас и находимся. 
![image](https://github.com/user-attachments/assets/a8bbbdb9-1d35-4746-95f7-61e2b37ab777)


Если введем команду **git status**, то теперь Гит знает что изменения в нашем файле уже готовы к сохранению.

![image](https://github.com/user-attachments/assets/0242aba7-0915-4b21-807a-3fe4534f9e8a)

То место, где сейчас гит хранит информацию о том, какие именно файлы готовы к коммиту, называется **ИНДЕКС ГИТА** (staging area)

Только те файлы, что находятся в индексе, попадут в следующий коммит.
Когда добавили изменения в индекс и теперь готовы сохранить в истории гита, то необходимо выполнить команду **git commit -m "{message}"**.

![image](https://github.com/user-attachments/assets/d0bbb318-d308-4bdd-83e2-dc981f7cc2dc)


У нее есть параметр "**-m**", после которого в ковычках можно указать сообщение **с описанием той версии файлов**, которую сохраняем
![image](https://github.com/user-attachments/assets/fe4b5331-fa02-458b-aab5-9132e2ef3c96)

Когда вы выполните git commit, то внутри гита создастся новый Чек-пойнт, который так и называется Коммит. По сути Гит запомнил то состояние файлов,  которое мы закоммитили. Теперь в любой момент сможем вернуться к этому состоянию. 

Коммитов можно делать сколько угодно, каждый раз сохраняя тем самым новые версии ваших файлов.
Гит  хранит всю историю коммитов.



## Снова изменим файл Readme и Создадим **еще один Коммит** в гите с еще одной версией этого файла.
1) Добавим в файл немного текста, 
2) Выполним команду git add . (помещаем измененные файлы в индекс)
3) **git commit -m "updated README again"** - сказать Гиту, что именно их мы хотим в будущем закоммитеть


![image](https://github.com/user-attachments/assets/9d67d13b-b5cd-4b2e-998e-184e470a324f)

У каждого коммита есть уникальный Хэш, который позволяет вернуться во времени к этой версии, которую сохраняли в этой точке.
Команда возвращает нас к предыдущей версии файла ( по хэшу коммита):
![image](https://github.com/user-attachments/assets/6dff14d1-420f-46ee-8d50-d735d942ddbb)


## Публикация изменений
Все эти коммиты находятся сейчасввашем Локальном репозитории.  Т.е. если мы работаем с командой над каким-то общим проектом, то другие участники всё еще не видят внесенных изменений.
Но мы можем все сделанные нами коммиты послать из локального репозитория на удаленный, чтобы другие участники команды могли скачать эти коммиты себе из удаленного репозитория.
Для того, чтобы загрузить сделанные коммиты в удаленный репозиторий, находясь в терминале внутри локального репозитория, выполняем команду:
**git push origin master**
(* Любой локальный в Гите знает свой удаленный репозиторий под кодовым именем **origin**. Далее указываем имя ветки изменений, в которую мы загружаем коммиты)
![image](https://github.com/user-attachments/assets/d432b2fc-4b5d-48f1-b36e-ee659d853ce3)

Гит начнет посылать наши коммиты и состояния файлов в них на сервера ГитХаб в наш удаленный репозиторий. 
В Гитхабе будет лежать уже измененный файл.


## Если другой разработчик захочет подтянуть из общего удаленного репозитория наши изменения.
ПредположимЮ что он клонировал свой проект еще ДО того, как вы запушили свои коммиты. Поэтому у него на компе всё еще старое состояние этого файла.

![image](https://github.com/user-attachments/assets/3da7b30c-bd31-4a7f-9304-3cbe31e98866)

Командой **git log** можем проверить, что состояние текущего файла еще старое, без изменений:
![image](https://github.com/user-attachments/assets/8f8360ac-98e7-400e-85da-eec164dce381)


А чтобы скачать наши коммиты из удаленного репозитория, нужно из директории его локального репозитория выполнить команду **git pull origin (имя ветки, из которой подгружаем коммиты) (URL удаленного репозитория)**
Например, **git pull origin master (URL удаленного репозитория)**
Тогда увидим у себя самую последнюю версию изменений. Получили все коммиты, всю историю.

Теперь если выполнить команду **git log**, то увидим все те коммиты, что до этого мы сделали в другом локальном репозитории и затем запушили их в удаленный.
Теперь мы уже из нового локального репозитория можем перемещаться точно так же, как и автор в оригинальном с помощью **git checkout**.


## ВЕТКИ
Ветка в Git - это последовательность коммитов, которые имеют определенное имя:
![image](https://github.com/user-attachments/assets/9c4f70ce-4a32-4d7b-8e10-fbaf1fc4c4a9)


Поэтому в любом локальном или удаленном репозитории всегда есть как **минимум одна ветка**. Она, как правило, называется **master** или **main**.

Но можем создавать сколько угодно других собственных веток. Для чего? Допустим, как разработчик мы работает над каким-то новым проектом и делаем огромную фичу. Она длинная 
- приходится изменить много файлов. Мы их постепенно меняем, добавляем новые коммиты.
  Но мы еще в процессе,  не закончили работу. Поэтому мы не хотели бы чтобы наши изменения прямо сейчас попадали в общий репозиторий. (Потому что тогда др. люди получат к ним доступ). У др. людей, которые
  скачают этот удаленный репозиторий с общими изменениями, будет нестабильная работа приложения - могут быть баги. 
Поэтому разработку отдельной ФИЧИ удобнее вести изолированно от стабильных коммитов, чтобы др. люди пока тоже могли работать  с репозиторием независимо от вас.

Когда мы создаем ветку в Git, то мы как бы отпачковываемся от существующей последовательности коммитов в новую изолированную со своим особым именем:

![image](https://github.com/user-attachments/assets/22b7fa4f-eb7a-4c37-be64-09f87141be85)

В локальном репозитории мы можем посмотреть какие ветки в репозитории есть сейчас с помощью команды **git branch**:
![image](https://github.com/user-attachments/assets/36099430-7916-4eda-be07-9d70e0f67c62)


![Uploading image.png…]()
 - В данном случае у нас только одна единственная ветка



