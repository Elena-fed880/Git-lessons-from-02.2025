- **`git branch [имя-ветки]`**
  Позволяет создать новую ветку.

- **`git checkout [имя-ветки/ имя-коммита]`**
  Переключается на указанную ветку и обновляет рабочую директорию

- **`git checkout -b [your branch name]`**
  Позволяет создать новую ветку и переключиться на неё с помощью одной команды:






### Git Rebase

Второй способ объединения изменений в ветках - это **rebasing**.(первый - **merge**) При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.

Несмотря на то, что это звучит достаточно непонятно, преимущество **rebase** в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете **rebase**.


- **`git rebase main`**
ДО:

<img src="https://github.com/user-attachments/assets/ba974c01-2706-4111-8330-2a18e7cbb6b3" width="80%" />

ПОСЛЕ:

<img src="https://github.com/user-attachments/assets/7f849d16-70c2-4d7f-9649-f046631609c6" width="70%" />

- **`git rebase bugFix`**

<img src="https://github.com/user-attachments/assets/3c1361fe-2cbb-4502-ad63-8c0bdf850641" width="70%" />

<img src="https://github.com/user-attachments/assets/a65fd0d2-ed34-4a8d-8804-98bb1d6731b5" width="70%" />



### HEAD
**HEAD** - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы **в данный момент** работаем.
HEAD всегда указывает на **последний коммит** из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.
Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.

<img src="https://github.com/user-attachments/assets/500cc074-d34f-4c83-a536-f57fa7636f29" width="70%" />


<img src="https://github.com/user-attachments/assets/33de0312-dd64-4c67-9dd3-e0756ecdc0c9" width="70%" />

<img src="https://github.com/user-attachments/assets/f14c9c51-7f71-4433-a835-a624df7ca3f2" width="70%" />


### Передвижение по дереву Git
#### Относительные ссылки
Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать git log, чтобы найти хеш нужного коммита

Более того, хеши в реальном репозитории Git намного более длинные. Например, хеш для коммита, который приведён в предыдущем уровне - **`fed2da64c0efc5293610bdd892f82a58e8cbc5d8`**. Не очень просто для произношения =)

Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто **`fed2`** вместо колбасы выше.

Указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки и они прекрасны!

С относительными ссылками можно начать с какого-либо удобного места (например, с ветки bugFix или от HEAD) и двигаться от него

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
- Перемещение на один коммит назад **`^`**
- Перемещение на несколько коммитов назад **`~<num>`**


ДО:

<img src="https://github.com/user-attachments/assets/7da3e70c-c432-4721-b171-f31169c79426" width="70%" />

ПОСЛЕ:

<img src="https://github.com/user-attachments/assets/f6984021-8795-4253-9a69-66492af6f9fa" width="70%" />



ДО:

<img src="https://github.com/user-attachments/assets/64c3cbd5-74fd-439d-a81b-a56168d5067b" width="70%" />

ПОСЛЕ:

<img src="https://github.com/user-attachments/assets/5a866c3a-2355-4182-be25-3c03b9163288" width="70%" />



#### Оператор "~"
Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать **`^`** несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (**`~`**).
К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Посмотрим, как это работает.


<img src="https://github.com/user-attachments/assets/64644fc6-b43b-4dc4-83ce-8fe88723fd63" width="70%" />

<img src="https://github.com/user-attachments/assets/4e271a2e-2c74-49e7-bd2a-309baab83b1c" width="70%" />


### Перемещение ветки (branch forcing)
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

- **`git branch -f main HEAD~3`**

Переместит (принудительно) ветку main на три родителя назад от HEAD.

<img src="https://github.com/user-attachments/assets/27e95966-8e2c-4fff-bea8-f970c63456b0" width="70%" />

<img src="https://github.com/user-attachments/assets/0bcbac4c-b3ec-4cc8-84a6-c6737d854fce" width="70%" />



ДО:

<img src="https://github.com/user-attachments/assets/10a2bd36-dee8-4f9a-8203-c5bc4023a405" width="70%" />

РЕШЕНИЕ:

<img src="https://github.com/user-attachments/assets/f222275c-8af8-4e72-92bc-5d4818d2b841" width="70%" />


## Отмена изменений в Git
Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: 
- первый - это **`git reset`**,
- а второй - **`git revert`**.

### Git Reset

- **`git reset HEAD~1`**

<img src="https://github.com/user-attachments/assets/0b8ac48c-e1fc-47c1-918c-0c8b22c4f870" width="70%" />

<img src="https://github.com/user-attachments/assets/f53e841e-3173-4b29-914a-a920f314fa45" width="70%" />


### Git Revert
- **`git revert HEAD`**

<img src="https://github.com/user-attachments/assets/d711d16c-b2d6-4911-a521-c384a10c0505" width="70%" />

<img src="https://github.com/user-attachments/assets/bd1a6b3f-7c87-4926-aca5-1cae3b9c7466" width="70%" />


ЗАДАЧА:
<img src="https://github.com/user-attachments/assets/f2ce0da1-a162-44be-bb17-74d9eb485df6" width="70%" />

РЕШЕНИЕ:
<img src="https://github.com/user-attachments/assets/9177eeb9-fe72-4f64-bdf2-83bfd637a0a6" width="70%" />


### Поперемещаем изменения
Итак, мы уже освоили основы Git: коммиты, ветки, перемещение по дереву изменений. Уже этих знаний достаточно, чтобы овладеть 90% мощи Git-репозиториев и покрыть нужды разработчиков.

А оставшиеся 10% будут очень полезны при сложных workflow (или если ты попал в сложную ситуацию). Теперь речь пойдёт о перемещении изменений — возможности, позволяющей разработчику сказать "Хочу, чтобы эти изменения были вот тут, а вот эти — вон там" и получить точные, правильные результаты, не теряя при этом гибкости разработки.


### Git Cherry-pick
Первая из таких команд - это git cherry-pick. Она выглядит вот так:

 - **`git cherry-pick <Commit1> <Commit2> <...>`**
Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.


<img src="https://github.com/user-attachments/assets/97a443a1-66e1-4964-ae58-ab77afab52f4" width="70%" />

ЗАДАЧА:

<img src="https://github.com/user-attachments/assets/e200d6ea-dc66-403b-9514-359ebcb86dad" width="70%" />

РЕШЕНИЕ:

**git cherry-pick  C3 C4 C7**


### Git Interactive Rebase
Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)

Но как быть в случае, когда точно не известно какие коммиты нужны? К счастью, Git позаботился о таких ситуациях! Можно использовать интерактивный **rebase** для этого - лучший способ отобрать набор коммитов для rebase.

Всё, что нужно для интерактивного rebase - это опция **`-i`**

Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель **rebase (target)**. Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.

Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе **типа vim**. Для этой обучалки, я сделал небольшое диалоговое окно, которое по сути делает то же, что и редактор.

После открытия окна интерактивного rebase есть три варианта для каждого коммита:

- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
- Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. В этом уровне игры у нас не реализована эта возможность, но, вкратце, при помощи этой функции можно объединять изменения двух коммитов.

- **`git rebase -i HEAD~4`**

<img src="https://github.com/user-attachments/assets/ab06c1ea-9876-43a3-85e5-c0eb4c523a97" width="70%" />

<img src="https://github.com/user-attachments/assets/96602284-1020-4a96-994f-d82571331b50" width="70%" />
 
<img src="https://github.com/user-attachments/assets/c4a25d63-8a83-439d-8f60-b38224d5734b" width="70%" />


## Жонглируем коммитами
Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом!


Преодолеть эти трудности можно следующим образом:

- Переставить коммит так, чтобы нужный находился наверху при помощи **`git rebase -i`**
- Внести изменения при помощи **`git commit --amend`**
- Переставить всё обратно при помощи **`git rebase -i`**
- И наконец, переместить **main** на изменённую часть дерева, чтобы закончить уровень.

ЗАДАЧА:
<img src="https://github.com/user-attachments/assets/9f66c148-b271-4237-9e79-6dfe0e2f23c5" width="70%" />

РЕШЕНИЕ:
1)

<img src="https://github.com/user-attachments/assets/34ad8dbc-8ff4-4e17-99e9-bd2f1812d5a4" width="40%" />

<img src="https://github.com/user-attachments/assets/48005853-a419-43e1-8219-b955673dfdbf" width="70%" />

2) 

<img src="https://github.com/user-attachments/assets/e341c8d1-004f-40aa-af45-00cf42473e64" width="70%" />





<img src="https://github.com/user-attachments/assets/aade5779-60b7-49da-9c5a-f95be967058c" width="70%" />



- **`git cherry-pick C2`**

<img src="https://github.com/user-attachments/assets/0fbd2ca5-1f24-4c8f-a378-f226b94b312e" width="70%" />

<img src="https://github.com/user-attachments/assets/d657e611-04c6-4181-8b59-a1c4ef749abf" width="70%" />



ЗАДАЧА:

<img src="https://github.com/user-attachments/assets/62bb1cb1-f797-47c6-978f-8adb739d9468" width="70%" />

РЕШЕНИЕ:

<img src="https://github.com/user-attachments/assets/62e9922a-9da2-43ad-b35f-069e5c32a9e2" width="70%" />


## Теги

- **`git tag V1 C1`**

В прошлых уроках мы усвоили, что ветки просто двигать туда-сюда и они часто ссылаются на разные коммиты как на изменения данных в ветке. Ветки просто изменить, они часто временны и постоянно меняют своё состояние.

В таком случае, где взять постоянную ссылку на момент в истории изменений? Для таких вещей, как релиз и большие слияния, нужно нечто более постоянное, чем ветка.


Такое средство имеется. Git предоставляет нам теги, чья основная задача – ссылаться постоянно на конкретный коммит.
Важно, что после создания они никогда не сменят своего положения, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений

<img src="https://github.com/user-attachments/assets/73e29e06-51c1-484f-8767-63e01a4f8285" width="70%" />

<img src="https://github.com/user-attachments/assets/29dc5592-9a19-41cf-b98e-e0a74cbfe3d2" width="70%" />



ЗАДАЧА:

Чтобы пройти этот уровень, просто создай теги так, как показано на визуализации, и потом перейди на тег `v1`. Обрати внимание, что ты перейдёшь в состояние `detached HEAD`, так как нельзя сделать коммит прямо в тег `v1`.

<img src="https://github.com/user-attachments/assets/b9897914-c8bf-4b23-b94a-fd3b7daf5c50" width="70%" />

РЕШЕНИЕ:

<img src="https://github.com/user-attachments/assets/da4f634f-af58-4d37-a1eb-1b8eb02e523b" width="70%" />




## Git Describe
Теги являются прекрасными ориентирами в истории изменений, поэтому в git есть команда, которая показывает, **как далеко текущее состояние от ближайшего тега**. И эта команда называется **`git describe`**

Git describe помогает сориентироваться после отката на много коммитов по истории изменений. Такое может случиться, когда вы сделали git bisect или если вы недавно вернулись из отпуска =)


Git describe выглядит примерно так:

 - **`git describe <ref>`**

Где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).

Вывод команды выглядит примерно так:

- **`<tag>_<numCommits>_g<hash>`**

Где **tag** – это ближайший тег в истории изменений, **numCommits** – это на сколько далеко мы от этого тега, а **hash** – это хеш коммита, который описывается.


<img src="https://github.com/user-attachments/assets/6225381b-00ab-4c93-acac-1c48d939095e" width="70%" />



### Rebase на нескольких ветках
У нас тут куча веток! Было бы круто перенести все изменения из них в мастер.

Но начальство усложняет нашу задачу тем, что желает видеть **все коммиты по порядку**. Так что коммит **С7'** должен идти после коммита **С6'** и так далее.
Если что-то пойдёт не так – не надо стесняться использовать **reset**, чтобы начать всё с чистого листа. Постарайся сделать как можно меньше манипуляций!

ЗАДАЧА:

<img src="https://github.com/user-attachments/assets/ec75eff4-2308-42f7-a16a-373c8c5f3650" width="70%" />

РЕШЕНИЕ (моё. Но можно как-то и короче) :

<img src="https://github.com/user-attachments/assets/bc8ba2d6-c05c-4926-ab58-be425f4ab2e5" width="70%" />



















