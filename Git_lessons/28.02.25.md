
# По видео с Ютуба:    https://youtu.be/VJm_AjiTEEc  (написала я)

Локальный репозиторий  и созданный на его основе удаленный репозиторий (копия локального) постоянно связаны м/у собой. Эту связь обеспечивает Git. 

![image](https://github.com/user-attachments/assets/a8625667-b5dd-454b-9d05-a62ea06b5d8a)


## Публикация изменений в файлах в GitHub:

Делая изменения в файлах в нашем локальном репозитории, когда мы готовы, то можем **сказать гиту**, чтобы он опубликовал все эти изменения в удаленную копию.
Но самостоятельно Гит ничего делать не будет!!!  Он опубликует, только когда вы явно ему скажете об этом.  
Поэтому не стоит переживать о том, что кто-то тут же увидит, какого кринжа вы навалили в коде.


Когда мы загрузим наш новый код в удаленный репозиторий, то другие смогут скачать его на свои ПК. (а точнее не его самого, а только **копию**)
Они возьмут ваш удаленный репозиторий и на своих ПК на его основе создадут локальный репозиторий. Но это будет уже другая копия, не такая же как у вас! У каждого пользователя своя копия репозитория.



## Скачивание копии удаленного репозитория на свой ПК:
Сначала в консоли нужно перейти в папку, куда хотим скачать копию удаленного репозитория. (с помощью команды cd в терминале)

Далее запускаем команду `git clone [url удаленного репозитория с GitHub]`?\. Например,   **git clone  https://github.com/Elenka-Frontendka/git_test.git**

![image](https://github.com/user-attachments/assets/dbb8ee95-91d0-46ee-bf27-4ba22af95fd8)

После этого у нас на компе появится новая папка со всеми файлами, что лежат в удаленном репозитории.
И эта папка сразу является вашим **локальным репозиторием**.
И этот локальный репозиторий уже автоматически связан с удаленным.
Но опять же, когда мы внесем какие-то изменения в локальном репозитории, они никак не будут отражены в удаленном!
Они появятся в удаленном, только когда мы явно скажем гиту о том, что нужно загрузить их в облако.

_____
Команда `git clone [url удаленного репозитория с GitHub]` скачивает из интернета (с сайта GitHub) нужный репозиторий на ваш компьютер. 

## КОММИТЫ. Внесение изменений в файл в вашем локальном репозитории.
В локальном репозитории есть файл README.md.   Внесем в него изменения (добавим такой-то текст)

Внутри репозитория можно выполнить команду **git status**. Она выведет нам в консоль информацию обо всех незакоммиченных файлах в Гит-репозитории (подсветит их красным). Т.е. о тех, чью версию мы изменили, но еще не сохранили эти изменения внутри Гита.

![image](https://github.com/user-attachments/assets/b923b41a-55dc-4a53-9d64-f08f0699f2dc)

Сохранение конкретной версии файла внутри Гита называется **коммитом**. Т.е. чтобы в будущем была возможность всегда быстро прыгнуть именно на эту версию файла, то это его состояние нужно закоммитеть в гит.

Сначала гиту нужно сказать, какие именно изменения в файле мы хотим сохранить в виде отдельной версии. (= коммита внутри гита)

![image](https://github.com/user-attachments/assets/fac78b6d-630c-40e7-965c-077e190151ad)

Используют команду **git add**. После этой команды нужно указать имена файлов или папок, которые хотим подготовитьк сохранению. 
Чтобы подготовить **сразу все** файлы из текущей директории, можно написать точку ".", которая указывает на директорию, в которой мы прямо сейчас и находимся.

![image](https://github.com/user-attachments/assets/a8bbbdb9-1d35-4746-95f7-61e2b37ab777)


Если введем команду **git status**, то теперь Гит знает что изменения в нашем файле уже готовы к сохранению.

![image](https://github.com/user-attachments/assets/0242aba7-0915-4b21-807a-3fe4534f9e8a)

То место, где сейчас гит хранит информацию о том, какие именно файлы готовы к коммиту, называется **ИНДЕКС ГИТА** (staging area)

Только те файлы, что находятся в индексе, попадут в следующий коммит.
Когда добавили изменения в индекс и теперь готовы сохранить в истории гита, то необходимо выполнить команду **git commit -m "{message}"**.

![image](https://github.com/user-attachments/assets/d0bbb318-d308-4bdd-83e2-dc981f7cc2dc)


У нее есть параметр "**-m**", после которого в ковычках можно указать сообщение **с описанием той версии файлов**, которую сохраняем

![image](https://github.com/user-attachments/assets/fe4b5331-fa02-458b-aab5-9132e2ef3c96)

Когда вы выполните **git commit**, то внутри гита создастся новый `Чек-пойнт`, который так и называется `Коммит`. По сути Гит запомнил то состояние файлов,  которое мы закоммитили. Теперь в любой момент сможем вернуться к этому состоянию по его номеру. У каждого коммита есть **уникальный номер** (хэш) 

Коммитов можно делать сколько угодно, каждый раз сохраняя тем самым новые версии ваших файлов.
Гит  хранит всю историю коммитов.



## Снова изменим файл README и Создадим **еще один Коммит** в гите с еще одной версией этого файла.
1) Добавим в файл немного текста, 
2) Выполним команду git add . (помещаем измененные файлы в индекс)
3) **git commit -m "updated README again"** - сказать Гиту, что именно их мы хотим в будущем закоммитеть


![image](https://github.com/user-attachments/assets/9d67d13b-b5cd-4b2e-998e-184e470a324f)

У каждого коммита есть уникальный Хэш, который позволяет вернуться во времени к этой версии, которую сохраняли в этой точке.
Команда `git checkout (хэш-номер коммита, к  которому я хочу вернуться)` возвращает нас к предыдущей версии файла ( по хэшу коммита):

![image](https://github.com/user-attachments/assets/6dff14d1-420f-46ee-8d50-d735d942ddbb)


## Публикация изменений
Все эти коммиты находятся сейчас в вашем Локальном репозитории.  Т.е. если мы работаем с командой над каким-то общим проектом, то другие участники всё еще не видят внесенных изменений.
Но мы можем **все сделанные нами коммиты послать из локального репозитория на удаленный**, чтобы другие участники команды могли скачать эти коммиты себе из удаленного репозитория.

Для того, чтобы загрузить сделанные коммиты в удаленный репозиторий, находясь в терминале внутри локального репозитория, выполняем команду:
`git push origin master`
(* Любой локальный репозиторий в Гите знает свой удаленный репозиторий под кодовым именем **origin**. Далее указываем имя ветки изменений, в которую мы загружаем коммиты)

![image](https://github.com/user-attachments/assets/d432b2fc-4b5d-48f1-b36e-ee659d853ce3)

Гит начнет посылать наши коммиты и состояния файлов в них на сервера ГитХаб в наш удаленный репозиторий. 
В Гитхабе будет лежать уже измененный файл с последним коммитом (но вся история изменений также там доступна).


## Если другой разработчик захочет подтянуть из общего удаленного репозитория наши изменения.
Предположим, что он клонировал свой проект еще ДО того, как вы запушили свои коммиты. Поэтому у него на компе всё еще старое состояние этого файла.
(Тут чтобы показать как это работает, мы можем создать на компе еще один 2-й локальный репозиторий, который привязан к тому же самому удаленному репозиторию)

![image](https://github.com/user-attachments/assets/3da7b30c-bd31-4a7f-9304-3cbe31e98866)

Командой **git log** можем проверить, что состояние текущего файла еще старое, без изменений:
![image](https://github.com/user-attachments/assets/8f8360ac-98e7-400e-85da-eec164dce381)


А чтобы скачать наши коммиты из удаленного репозитория, нужно из директории **его** локального репозитория выполнить команду `git pull origin (имя ветки, из которой подгружаем коммиты)`
Например, **git pull origin master**
Тогда увидим у себя на ПК самую последнюю версию изменений. Но мы получили не просто последнюю версию, а получили все коммиты, всю историю.

Теперь если выполнить команду **git log**, то увидим все те коммиты, что до этого мы сделали в другом локальном репозитории и затем запушили их в удаленный.
Теперь мы уже из нового локального репозитория можем перемещаться по этим коммитам точно так же, как и автор в оригинальном с помощью **git checkout**.


## ВЕТКИ, переход на новую ветку 
Ветка в Git - это последовательность коммитов, которые имеют определенное имя:

![image](https://github.com/user-attachments/assets/9c4f70ce-4a32-4d7b-8e10-fbaf1fc4c4a9)

Поэтому в любом локальном или удаленном репозитории всегда есть как **минимум одна ветка**. Она, как правило, называется **master** или **main**.

Но можем создавать сколько угодно других собственных веток. ``Для чего?`` Допустим, как разработчик мы работает над каким-то новым проектом и делаем огромную фичу. Она длинная 
- приходится изменить много файлов. Мы их постепенно меняем, добавляем новые коммиты.
  Но мы еще в процессе,  не закончили работу. Поэтому мы не хотели бы чтобы наши изменения прямо сейчас попадали в общий репозиторий. (Потому что тогда др. люди получат к ним доступ). У др. людей, которые
  скачают этот удаленный репозиторий с общими изменениями, будет нестабильная работа приложения - могут быть баги. 
Поэтому разработку отдельной ФИЧИ удобнее вести изолированно от стабильных коммитов, чтобы др. люди пока тоже могли работать  с репозиторием независимо от вас.

Когда мы создаем ветку в Git, то мы как бы отпачковываемся от существующей последовательности коммитов в новую изолированную со своим особым именем:

![image](https://github.com/user-attachments/assets/22b7fa4f-eb7a-4c37-be64-09f87141be85)

В локальном репозитории мы можем посмотреть какие ветки в репозитории есть прямо сейчас с помощью команды `git branch`:

![image](https://github.com/user-attachments/assets/36099430-7916-4eda-be07-9d70e0f67c62)


![image](https://github.com/user-attachments/assets/6ffd6b4a-55b9-43fc-901c-8643a37b1941)
 - В данном случае у нас только одна единственная ветка

Чтобы из ветки master создать новую ветку, нужно выполнить команду `git branch (имя новой ветки)`

![image](https://github.com/user-attachments/assets/75b33a3b-d704-4d94-80da-212f179ee2a9)
-тут мы просто создали новую ветку, но находимся всё еще на старой. 

Чтобы перейти на новую ветку: `git checkout (имя ветки, на которую хотим перейти)`

![image](https://github.com/user-attachments/assets/bb9bf4c6-6ae1-45a0-9c17-32910982f8ad)

![image](https://github.com/user-attachments/assets/603a234d-3bde-4814-819e-4a24e9a509a0)

![image](https://github.com/user-attachments/assets/dd8fe446-f505-4998-9a12-a7fcedb1dae7)

 - звездочка рядом с названием ветки показывает, что мы переключились и работаеи  уже на этой ветке.


Когда мы создаем новую ветку, по умолчанию она создается на основе последнего коммита той ветки. на которой мы находились в  момент создания.
 - Таким образом, сейчас файлы ветки `master` и новой ветки `feature` абсолютно идентичные.

Теперь, если находясь в новой ветке, мы изменим наш файл README и по старой схеме сделаеи коммит наших изменений, то коммит будет сделан именно в  этой ветке, а не в master! :

![image](https://github.com/user-attachments/assets/2fee2a4e-2810-47df-bcb7-9013258a0f41)

Если хотим переключиться на стабильную версию изменений в мастере, то достаточно просто вернуться на ветку master и все файлы будут автоматически 
соответствовать  последнему коммиту в мастере.

README будет в начальном состоянии, откуда мы пришли:

![image](https://github.com/user-attachments/assets/ac4af180-cc15-4c50-8306-6686c00569c1)


Если теперь мы снова захотим вернуться на вторую ветку и продолжить неоконченную работу, то делаем чекаут на нее:    `git checkout feature` и обнаруживаем файл README  в том состоянии, в котором мы его и оставили

Т.о. разные разработчики могут работать в своих отдельных ветках, не мешая друг другу. Потом эти ветки могут оказаться в мастере, когда будут доведены до конца.



Сейчас новая ветка feature является локальной - она существуетв= в нашем локальном репозитории, но ее еще нет в удаленном. Т.е.  другие ее пока не могут увидеть:

![image](https://github.com/user-attachments/assets/3855556b-565b-4dc7-a156-ca94d07836ba)


Чтобы ее опубликовать, выполняем `git push origin feature`, находясь в локальной ветке, которую мы хотим опубликовать
Здесь вместо feature можно написать любое имя. Это имя ветки, которое мы хотим дать новой УДАЛЕННОЙ ветке на GitHub, в которую загрузим локальную ветку feature.
Обычно ее называют точно также, как она названа у нас и локально, чтобы не путаться.

После этого коммит из локальной ветки публикуется в удаленном репозитории. Но теперь и другие участники команды могут видеть нашу ветку и переключаться м/у ею и мастером (также как и вы)

![image](https://github.com/user-attachments/assets/e55b2730-ce4b-4790-a37c-fc4d21794348)


## СЛИЯНИЕ 
Допустим мы длительное время работали над какой-то фичёй и делали коммиты в ветке и наконец она готова и стабильна.
А теперь хотим перенести все изменения из ветки для разработки feature в основную ветку master, чтобы все получили к ним доступ.
Также ваши изменения соединятся с остальными изменениями из других веток, которые др. разработчики тоже объединяют в мастер.
Такая процедура  в Git называется **слиянием веток**.


Есть 2 механизма слияния:
## 1 способ - Мёдж. 
Сначала нужно сделать checkout на ту ветку, в которую мы будем делать мёрдж.    `git checkout master`

А затем выполнить команду `git merge` с именем ветки, из которой мы будем проводить слияние `git merge feature`

В этот момент Гит берет все изменения из переданной ветки, и добавляет все их в ветку Master  в виде всего одного нового коммита.

Убедиться в этом можно, выполнив из мастера команду  git log:

![image](https://github.com/user-attachments/assets/176cb632-b677-4afd-8b94-e4a42bc4aedc)

- тут видно, что сначала идут пара наших старых коммитов, а последним (сверху) появляется новый.

Если, находясь на ветке master, мы взглянем на состояние нашего файла README, то увидим что оно совпадает с тем что мы до этого видели во второй ветки.
Т.е. все изменения попали в master и сущестуют здесь в виде одного нового коммита.

Далее, если хотим опубликовать результат Мерджа, то нужно сделать **push** мастера в удаленный репозиторий.


![image](https://github.com/user-attachments/assets/47ad0e7e-1c2a-40c3-b963-75a62319b8de)

![image](https://github.com/user-attachments/assets/d2bb10d0-97f0-4459-bf37-b8d5479259dc)


## 2 способ. 
Вернемся на вторую ветку: `git checkout feature` и сделаем на ней новые изменения в файле README 
Затем сделаем пару дополнительных коммитов.

Заглянем в git log:

![image](https://github.com/user-attachments/assets/b6a03a96-df39-4098-a092-f4fff95c3acd)

 - убеждаемся что там есть новые коммиты, которые мы только что сделали. 
Хотим эти изменения перенести в ветку master.
Но merge в мастере создает только 1 новый коммит, в котором лежат все изменения из 2й ветки, которую мы мёржили.

Но что если я хочу поддержать историю изменений и перевести все коммиты из второй ветки в master?
Для этого можем использовать команду `git rebase (имя ветки)` вместо `git merge feature`


![image](https://github.com/user-attachments/assets/a97098a8-7672-4c1e-b78d-dfc5b129cb8e)

![image](https://github.com/user-attachments/assets/21c94f9a-1179-4305-a923-59fe826478ae)

Теперь оба коммита из нашей 2-й ветки находятся здесь вместе со своими сообщениями.


![image](https://github.com/user-attachments/assets/94925934-feee-4ff6-a4d5-c5de3fd22b91)

Т.о., если вам важна история коммитов в вашей ветке, то лучше применять rebase вместо merge.



