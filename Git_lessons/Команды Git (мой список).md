- **`git branch [имя-ветки]`**
  Позволяет создать новую ветку.

- **`git checkout [имя-ветки/ имя-коммита]`**
  Переключается на указанную ветку и обновляет рабочую директорию

- **`git checkout -b [your branch name]`**
  Позволяет создать новую ветку и переключиться на неё с помощью одной команды:






### Git Rebase

Второй способ объединения изменений в ветках - это **rebasing**.(первый - **merge**) При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.

Несмотря на то, что это звучит достаточно непонятно, преимущество **rebase** в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете **rebase**.



ДО:

<img src="https://github.com/user-attachments/assets/ba974c01-2706-4111-8330-2a18e7cbb6b3" width="80%" />

ПОСЛЕ:

<img src="https://github.com/user-attachments/assets/7f849d16-70c2-4d7f-9649-f046631609c6" width="70%" />



<img src="https://github.com/user-attachments/assets/3c1361fe-2cbb-4502-ad63-8c0bdf850641" width="70%" />

<img src="https://github.com/user-attachments/assets/a65fd0d2-ed34-4a8d-8804-98bb1d6731b5" width="70%" />



### HEAD
**HEAD** - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы **в данный момент** работаем.
HEAD всегда указывает на **последний коммит** из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.
Обычно HEAD указывает на имя ветки (например, bugFix). Когда вы делаете коммит, статус ветки bugFix меняется и это изменение видно через HEAD.

<img src="https://github.com/user-attachments/assets/500cc074-d34f-4c83-a536-f57fa7636f29" width="70%" />


<img src="https://github.com/user-attachments/assets/33de0312-dd64-4c67-9dd3-e0756ecdc0c9" width="70%" />

<img src="https://github.com/user-attachments/assets/f14c9c51-7f71-4433-a835-a624df7ca3f2" width="70%" />


### Передвижение по дереву Git
#### Относительные ссылки
Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать git log, чтобы найти хеш нужного коммита

Более того, хеши в реальном репозитории Git намного более длинные. Например, хеш для коммита, который приведён в предыдущем уровне - **`fed2da64c0efc5293610bdd892f82a58e8cbc5d8`**. Не очень просто для произношения =)

Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто **`fed2`** вместо колбасы выше.

Указание на коммит при помощи его хеша - не самый удобный способ, поэтому Git поддерживает относительные ссылки и они прекрасны!

С относительными ссылками можно начать с какого-либо удобного места (например, с ветки bugFix или от HEAD) и двигаться от него

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:
- Перемещение на один коммит назад **`^`**
- Перемещение на несколько коммитов назад **`~<num>`**


ДО:

<img src="https://github.com/user-attachments/assets/7da3e70c-c432-4721-b171-f31169c79426" width="70%" />

ПОСЛЕ:

<img src="https://github.com/user-attachments/assets/f6984021-8795-4253-9a69-66492af6f9fa" width="70%" />



ДО:

<img src="https://github.com/user-attachments/assets/64c3cbd5-74fd-439d-a81b-a56168d5067b" width="70%" />

ПОСЛЕ:

<img src="https://github.com/user-attachments/assets/5a866c3a-2355-4182-be25-3c03b9163288" width="70%" />



#### Оператор "~"
Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать **`^`** несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (**`~`**).
К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Посмотрим, как это работает.


<img src="https://github.com/user-attachments/assets/64644fc6-b43b-4dc4-83ce-8fe88723fd63" width="70%" />

<img src="https://github.com/user-attachments/assets/4e271a2e-2c74-49e7-bd2a-309baab83b1c" width="70%" />


### Перемещение ветки (branch forcing)
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

- **`git branch -f main HEAD~3`**

Переместит (принудительно) ветку main на три родителя назад от HEAD.

<img src="https://github.com/user-attachments/assets/27e95966-8e2c-4fff-bea8-f970c63456b0" width="70%" />

<img src="https://github.com/user-attachments/assets/0bcbac4c-b3ec-4cc8-84a6-c6737d854fce" width="70%" />



ДО:

<img src="https://github.com/user-attachments/assets/10a2bd36-dee8-4f9a-8203-c5bc4023a405" width="70%" />

РЕШЕНИЕ:

<img src="https://github.com/user-attachments/assets/f222275c-8af8-4e72-92bc-5d4818d2b841" width="70%" />


## Отмена изменений в Git
Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: 
- первый - это **`git reset`**,
- а второй - **`git revert`**.

### Git Reset

- **`git reset HEAD~1`**

<img src="https://github.com/user-attachments/assets/0b8ac48c-e1fc-47c1-918c-0c8b22c4f870" width="70%" />

<img src="https://github.com/user-attachments/assets/f53e841e-3173-4b29-914a-a920f314fa45" width="70%" />




