- **`HEAD`** - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева.
Обычно HEAD указывает на имя ветки (например, bugFix).

Отделение **(detaching) HEAD** означает лишь присвоение HEAD не ветке, а конкретному коммиту.

! Изначально **HEAD**  указывает на ветку. Но если явно выполнить команду **`git checkout [имя-коммита = идентификатор коммита]`** - уже указывает сразу на нужный нам коммит. (присваивается коммиту)

- **`git log`** -  чтобы найти хеш нужного коммита

- **`git branch [имя-ветки]`**     Создать новую ветку. (Например, **`git branch newImage`** - данная ветка указывает на  коммит HEAD )

- **`git checkout [имя-коммита С1]`** - смещает **`HEAD`** на **`C1`**. Но имя ветки не изменяет свою ссылку (оно всё еще ссылается на старый коммит)
  
- **`git checkout [имя-ветки / имя-коммита]`**  Переключается на указанную ветку и обновляет рабочую директорию (Например, **`git checkout newImage`** )

- **`git checkout -b [your branch name]`**   Позволяет создать новую ветку и переключиться на неё с помощью одной команды

- **`git commit`**    Создаёт новый коммит в текущей ветке

- **`git merge [имя-ветки]`** Слияние этой ветки с той, которая сейчас у нас выбрана (отмечена звездочкой). Объединяет изменения из двух разных веток (слияния в Git)

Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими. Текущая ветка в результате будет указывать на коммит, у которого 2 родителя.



- **`git rebase [имя-ветки]`**    Копирует все новые коммиты из выбранной ветки (отмечена звездочкой)  на вершину ветки [имя-ветки]. (Другая ветка, с которой скопировалось, пропадает? )
При ребейзе Git  копирует набор коммитов и переносит их в другое место.

Но например, если ветка **`main`** была предком ветки **`bugFix`**, git просто сдвигает ссылку на **`main`** вперёд. (Теперь обе ссылки указывают на один и тот же коммит)



## Относительные ссылки 
- используют для перемещения по дереву ссылки HEAD вместо использования хэша.

- **`^`**(оператор каретки) - перемещение на один коммит назад
Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
**main^** означает "первый родитель ветки main";     **main^^** означает прародитель (родитель родителя) main

- **`~<num>`** - перемещение на несколько коммитов назад. Используют, когда нужно переместиться на много шагов назад по дереву.

**`git checkout HEAD~4`**  - переместит HEAD на 4 коммита назад относительно его текущего положения.


2 способа перемещения - относительно текущего положения HEAD и относительно указателя ветки.

- **`gitout main^`** - HEAD будет указывать на родителя того коммита, на которого указывает ветка main.

Можно также использовать HEAD как относительную ссылку. Пример:
- **`git checkout C3; git checkout HEAD^; git checkout HEAD^`** - ссылка HEAD переместится на 2 коммита назад от коммита C3


## Перемещение ветки (branch forcing)
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. 
Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

- **`git branch -f main HEAD~3`**   Переместит (принудительно) указатель ветки main на три родителя назад от HEAD.
- **`git branch -f main C6`**      Переместит (принудительно) указатель ветки main на коммит C6

##  Отмена изменений в Git
- **`git reset  HEAD~1`**  отменяет изменения, перенося ссылку на ветку назад, на более старый коммит.
  Локальный репозиторий окажется в состоянии, как будто последний коммит никогда не существовал.
  Но этот метод переписывания истории **не сработает на удалённых ветках**, которые используют другие пользователи.
  
- **`git revert HEAD`**   Чтобы отменить изменения и поделиться отменёнными изменениями с остальными.
  Добавится новый коммит, который содержит изменения, полностью противоположные тем, что сделаны в прежнем коммите.

После revert можно сделать push и поделиться изменениями с остальными.

  
## Поперемещаем изменения

- **`git cherry-pick <Commit1> <Commit2> <...>`**   копировать несколько коммитов на место, где сейчас находишься (HEAD)  (они добавятся после текущего коммита).
Пример: **git cherry-pick C2 C4**

Также можно перемещать коммиты с помощью команды **rebase**, но тогда там переместятся сразу все коммиты из ветки.  А с помощью cherry-pick можем переместить только выбранные.

- **`git rebase -i HEAD~4`** - откроет интерфейс с 4-мя коммитами
 Git скопирует коммиты в точности так, как будет указано через интерфейс! (переместит/ удалит/ объединит некоторые из них). Скопирует их **в новую ветку**.

Используют, когда неизвестны хэши коммитов, которые нужно переместить. Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target).
Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim.

После открытия окна интерактивного rebase есть три варианта для каждого коммита:

- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе.
- Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. При помощи этой функции можно объединять изменения двух коммитов.





















































