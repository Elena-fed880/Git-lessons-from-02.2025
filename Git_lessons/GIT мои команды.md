- **`HEAD`** - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева.
Обычно HEAD указывает на имя ветки (например, bugFix).

Отделение **(detaching) HEAD** означает лишь присвоение HEAD не ветке, а конкретному коммиту.

! Изначально **HEAD**  указывает на ветку. Но если явно выполнить команду **`git checkout [имя-коммита = идентификатор коммита]`** - уже указывает сразу на нужный нам коммит. (присваивается коммиту)

- **`git log`** -  чтобы найти хеш нужного коммита

- **`git branch [имя-ветки]`**     Создать новую ветку. (Например, **`git branch newImage`** - данная ветка указывает на  коммит HEAD )

- **`git checkout [имя-коммита С1]`** - смещает **`HEAD`** на **`C1`**. Но имя ветки не изменяет свою ссылку (оно всё еще ссылается на старый коммит)
  
- **`git checkout [имя-ветки / имя-коммита]`**  Переключается на указанную ветку и обновляет рабочую директорию (Например, **`git checkout newImage`** )

- **`git checkout -b [your branch name]`**   Позволяет создать новую ветку и переключиться на неё с помощью одной команды

- **`git commit`**    Создаёт новый коммит в текущей ветке

- **`git merge [имя-ветки]`** Слияние этой ветки с той, которая сейчас у нас выбрана (отмечена звездочкой). Объединяет изменения из двух разных веток (слияния в Git)

Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими. Текущая ветка в результате будет указывать на коммит, у которого 2 родителя.



- **`git rebase [имя-ветки]`**    Копирует все новые коммиты из выбранной ветки (отмечена звездочкой)  на вершину ветки [имя-ветки]. (Другая ветка, с которой скопировалось, пропадает? )
При ребейзе Git  копирует набор коммитов и переносит их в другое место.

Но например, если ветка **`main`** была предком ветки **`bugFix`**, git просто сдвигает ссылку на **`main`** вперёд. (Теперь обе ссылки указывают на один и тот же коммит)
-  **`git rebase bugFix main`**




## Относительные ссылки 
- используют для перемещения по дереву ссылки HEAD вместо использования хэша.

- **`^`**(оператор каретки) - перемещение на один коммит назад
Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.
**main^** означает "первый родитель ветки main";     **main^^** означает прародитель (родитель родителя) main

- **`~<num>`** - перемещение на несколько коммитов назад. Используют, когда нужно переместиться на много шагов назад по дереву.

**`git checkout HEAD~4`**  - переместит HEAD на 4 коммита назад относительно его текущего положения.


2 способа перемещения - относительно текущего положения HEAD и относительно указателя ветки.

- **`git checkout main^`** - HEAD будет указывать на родителя того коммита, на которого указывает ветка main.

Можно также использовать HEAD как относительную ссылку. Пример:
- **`git checkout C3; git checkout HEAD^; git checkout HEAD^`** - ссылка HEAD переместится на 2 коммита назад от коммита C3


## Перемещение ветки (branch forcing)
Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.
Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. 
Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

- **`git branch -f main HEAD~3`**   Переместит (принудительно) указатель ветки main на три родителя назад от HEAD.
- **`git branch -f main C6`**      Переместит (принудительно) указатель ветки main на коммит C6

##  Отмена изменений в Git
- **`git reset  HEAD~1`**  отменяет изменения, перенося ссылку на ветку назад, на более старый коммит.
  Локальный репозиторий окажется в состоянии, как будто последний коммит никогда не существовал.
  Но этот метод переписывания истории **не сработает на удалённых ветках**, которые используют другие пользователи.
  
- **`git revert HEAD`**   Чтобы отменить изменения и поделиться отменёнными изменениями с остальными.
  Добавится новый коммит, который содержит изменения, полностью противоположные тем, что сделаны в прежнем коммите.

После revert можно сделать push и поделиться изменениями с остальными.

  
## Перемещаем изменения

- **`git cherry-pick <Commit1> <Commit2> <...>`**   копировать несколько коммитов  и поместить их на место, где сейчас находишься (HEAD)  (они добавятся сразу после HEAD). (только если этот коммит не является предком HEAD)
Пример: **git cherry-pick C2 C4**

Также можно перемещать коммиты с помощью команды **`git rebase [имя-ветки]`**, но тогда там переместятся сразу все коммиты из ветки.  А с помощью cherry-pick можем переместить только выбранные.

- **`git rebase -i HEAD~4`** - откроет интерфейс с 4-мя коммитами
 Git скопирует коммиты в точности так, как будет указано через интерфейс! (переместит/ удалит/ объединит некоторые из них). Скопирует их **в новую ветку**.

Используют, когда неизвестны хэши коммитов, которые нужно переместить. Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target).
Для "реального" Git, этот интерфейс означает просто открытие файла в редакторе типа vim.

После открытия окна интерактивного rebase есть три варианта для каждого коммита:

- Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе.
- Можно "выкинуть" коммит из ребейза. Для этого есть pick - переключение его означает, что нужно выкинуть коммит.
- Наконец, можно соединить коммиты. При помощи этой функции можно объединять изменения двух коммитов.

-  **`git rebase -i main`** - скопирует и добавит в ветку main измененные в интерфейсе коммиты. (В интерфейсе работаем со всеми коммитами, которые есть в текущей ветке)


## Внести изменения в старый коммит
Порядок действий:
- Переставить коммит так, чтобы нужный находился в конце при помощи **git rebase -i**. Как только нужный нам коммит окажется в конце, мы можем спокойно изменить его при помощи --amend и переставить обратно.
- Внести изменения при помощи **git commit --amend**
- Переставить всё обратно при помощи **git rebase -i**
- И наконец, переместить main на изменённую часть дерева, чтобы закончить уровень.

Также  в качестве альтернативы можно применить **`cherry-picking`**.


## Теги
Ветки просто изменить, они часто временны и постоянно меняют своё состояние. В таком случае, где взять постоянную ссылку на момент в истории изменений? 
Для таких вещей, как релиз и большие слияния, нужно нечто более постоянное, чем ветка.
Такое средство имеется. Git предоставляет нам теги, чья основная задача – **ссылаться постоянно на конкретный коммит**.
Важно, что после создания они **никогда не сменят своего положения**, так что можно с лёгкостью сделать checkout конкретного момента в истории изменений/

Создадим тег на коммит C1, который будет нашей версией 1:
- **`git tag v1 C1`**    Мы назвали тег v1 и заставили его ссылаться на C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD.

<img src="https://github.com/user-attachments/assets/9c9b78ba-df21-432c-be03-0d3fa3994f31" width="30%" />


-  **`git checkout v1`** переход на тэг v1
-  переход в состояние **detached HEAD**, так как нельзя сделать коммит прямо в тег **`v1`**.



- **`git describe`**   команда, которая показывает, как далеко текущее состояние от ближайшего **тега**. 
Git describe помогает сориентироваться после отката на много коммитов по истории изменений.






























