- **`HEAD`** - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.
HEAD всегда указывает на последний коммит из вашего локального дерева.
Обычно HEAD указывает на имя ветки (например, bugFix).

Отделение **(detaching) HEAD** означает лишь присвоение HEAD не ветке, а конкретному коммиту.

! Изначально **HEAD**  указывает на ветку. Но если явно выполнить команду **`git checkout [имя-коммита = идентификатор коммита]`** - уже указывает сразу на коммит. (присваивается коммиту)


- **`git branch [имя-ветки]`**     Создать новую ветку. (Например, **`git branch newImage`** - данная ветка указывает на  коммит HEAD )

-  **`git checkout [имя-коммита С1]`** - смещает **`HEAD`** на **`C1`**. Но имя ветки не изменяет свою ссылку (оно всё еще ссылается на старый коммит)
  
-  **`git checkout [имя-ветки / имя-коммита]`**  Переключается на указанную ветку и обновляет рабочую директорию (Например, **`git checkout newImage`** )

- **`git checkout -b [your branch name]`**   Позволяет создать новую ветку и переключиться на неё с помощью одной команды

- **`git commit`**    Создаёт новый коммит в текущей ветке

- **`git merge [имя-ветки]`** Слияние этой ветки с той, которая сейчас у нас выбрана (отмечена звездочкой). Объединяет изменения из двух разных веток (слияния в Git)

Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими. Текущая ветка в результате будет указывать на коммит, у которого 2 родителя.



- **`git rebase [имя-ветки]`**    Копирует все новые коммиты из выбранной ветки (отмечена звездочкой)  на вершину ветки [имя-ветки]. (Другая ветка, с которой скопировалось, пропадает? )
При ребейзе Git  копирует набор коммитов и переносит их в другое место.

Но например, если ветка **`main`** была предком ветки **`bugFix`**, git просто сдвигает ссылку на **`main`** вперёд. (Теперь обе ссылки указывают на один и тот же коммит)


